---
layout: post
lead: Shreyas, Eric, Jacob
title: "babble: Learning Better Abstractions with E-Graphs and Anti-Unification"
paper: "https://arxiv.org/abs/2212.04596"
---

# Overview

This paper tackles _Library Learning_(finding common abstractions within a corpus of programs) with E-Graphs. Because finding the smallest equivalent program is something E-Graphs do easily, using E-Graphs for Library learning reframes the problem as one of _compression_: finding abstractions which best reduce the total size of the given corpus plus the new library. 

We go about this by:

1. First, we take our input corpus of programs and generate an e-graph and run equality saturation (as usual).
2. Next (and first big idea of the paper), we generate candidate abstractions by running an _anti-unification_ algorithm to find "the most concrete pattern that matches two given terms". The insight of the paper is how to apply this algorithm to e-classes instead of individual nodes in an AST.
3. Now that we've generated some candidate abstractions, we need to find the subset of them which reduces the size of the entire corpus. We do this by reframing the problem as an E-graph problem: we simply feed back in the candidate abstractions as rewrite rules to our e-graph, and then finding the smallest term.

# Anti-Unification

The basic idea behind _Anti-Unification_ is finding the "most _concrete_ pattern that matches two given terms". To do this, we walk the ASTs of each term until we find a mismatch, at which point we replace it with a variable (page 7 has a nice example). We keep track of these variable substitutions as a pair, so that if we encounter this pair later on in our traversal, we can replace it with the same variable. 

When we map this to e-classes, we unify two e-classes by following a similar top-down traversal, but this time as we're replacing inconsistent terms in our traversal with variables which stand in for child e-classes, resulting in a set of anti-unification patterns. Running this algorithm naively, because of how big e-classes can get, will blow up our set of anti-unifiers (including when there are cycles in our e-classes). 

To account for this we enforce that we only want _dominating_ anti-unification patterns, which allows us to rule out a lot of our potential anti-unification set. A pattern p1 _dominates_ another p2 if it matches the same e-classes and 1. p1 contains an inclusive subset of the variables of p2 (p1 is at least as concrete as p2) and 2. the size of p1 is at least as small as p2. If both of these are true, given our goal of reducing size, we know that we will never need p2 as a candidate pattern, so we can discard it. (This allows us to discard patterns built on following cycles in the e-classes). 

# Candidate Extraction

Now that we've generated some candidate abstractions



# Reading Order
We'd recommend starting with Section 1 to understand the problem and the paper's framing, then reading Section 2 (Overview) in detail, which does a great job of explaining the intuition behind the main contributions. Sections 3,4, and 5 are close walkthroughs of the details. If you're very comfortable reading this kind of literature, you might be able to briefly skim section 3 which motivates the two contribution sections: 4 (anti-unification on e-graphs) and 5 (candidate selection). The evaluation (section 6) was well-written but felt fairly standard and straightforward, and therefore less relevant to our class discussion.  

Fig 9. on pg 16 was particularly helpful for understanding the concrete steps of the algorithm. 
